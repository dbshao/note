<small>
1、多态
   1）、两种表现形式:
	a、一个对象，多种形态。
	   同一个对象，在不同场合下，
		表现出不同的形态，能完成不同的功能。

		在java中，往往使用implements关键字，实现多个接口。
	
		//同一个人
		CC peo = new CC();
		
		//同一个人，在不同的场合，表现出不同的形态
		//不同角色，表现的行为也不一样。
		Teacher teacher = peo;
		teacher.teach();//老师可以讲课
		
		Father father = peo;
		father.talkToSon();//父亲教育孩子
		
		Husband husband = peo;
		husband.giveMySalary();//丈夫上交工资

	b、多个对象，同一形态。
		不同对象，向上造型成同一种类型。
		实现相同的功能。
		
		在java中，往往使用extends关键字，继承同一个父类。
	
	   	Tiger tiger = new Tiger();
		tiger.name = "小王";
		
		Snake snake = new Snake();
		snake.name = "莽山烙铁头";
		
		Lion lion = new Lion();
		lion.name = "东北狮王";
		
		//不同对象，表现出同一种形态。
		Animal animal1 = tiger;
		Animal animal2 = snake;
		Animal animal3 = lion;

2、引用类型强制类型转换
   	回顾：基本类型强制类型转换
	long l = 1000;
	int i = (int)l;
	byte b = (byte)i;//溢出


	Animal animal = new Tiger();
	animal.name = "小王";
		
	//引用类型强制类型转换
	Lion lion = (Lion)animal;//错误，会导致类型转换异常ClassCastException
	
   instanceof关键字：
	可用于在引用类型转换之前，实现类型判断。
	符合转换匹配的类型，方能实现强制类型转换。

	有效的避免了引用类型转换异常的发生。

	语法：
	大类型 大类型引用 = new 小类型();
	
	if(大类型引用 instanceof 小类型){//类型判断
		//类型匹配
		小类型 小类型引用 = (小类型)大类型引用;
	}
		
	//引用类型强制类型转换
	Lion lion = (Lion)animal;//错误
	改造成
	if(animal instanceof Lion){
		//只有匹配才能进来
		Lion lion = (Lion)animal;
	}
	
>3、方法重写要求：
	a、发生在子父类之间
	b、方法名相同、参数列表相同
	c、访问权限不能变小
	d、抛出异常不能变大
	e、返回值类型可以是本类或其子类

********************** pm ************************
1、内部类
   class：类
	class：实体类
	abstract class：抽象类

   1）、内部类
	定义在类内部的类，称为内部类。
	类内部：
	   类体、方法体。
	
   2）、内部类定义
	外部类：定义了内部类的类。
	内部类：定义在外部类中的类。

	class Outer{//外部类
		class Inner{//内部类

		}
	}
	只要是类，类中可定义：成员变量、方法、静态块。

   3）、内部类的使用
	a：创建内部类对象
	   step1：先创建外部类对象。
	   step2：再通过外部类创建内部类对象。
		
b、在外部类外面
		对内部类属性使用、方法调用
	   与普通类的属性使用、方法调用一致。
		通过引用.属性，引用.方法
	
c、内部类中(**注意)
		调用内部类属性：this.属性;
		调用外部类属性：外部类名.this.属性;

   4）、内部类意义
	封装在内部类的中代码，不可以直接访问，必须先创建
	外部类对象，通过外部类对象创建内部类对象，才能访问。
	一定程度上，起到了代码保护效果。

>PS：普通内部类很少使用。

2、匿名内部类
   1）、匿名内部类
```
	class Outer{//外部类
		class {//匿名内部类？？？？？？
}
	}
上述定义是错误的。
```

   2）、匿名内部类定义
	某个类的匿名内部类，并非直接在类中定义。
	在外部类对象创建的时候定义。
step1：先创建外部类对象
		OuterClass outer = new OuterClass();
	step2：在外部类创建对象的()与;中间，
		添加一对{}，则{}即为匿名内部类类体。
step3：匿名内部类中可以定义属性、方法。

   3）、匿名内部的使用。
	匿名内部类属性，只能在匿名内部类中使用。

	匿名内部类的方法，无法直接“调用”。
	   只能通过匿名内部类重写外部类的方法，才能调用。

   4）、****什么时候使用匿名内部类?
	抽象类、接口都是无法实例化的。

	抽象类 引用 = new 抽象类();//不可以
	接口 引用 = new 接口();//不可以

	如何实现抽象类、接口的“实例化”？
	    都是先让实体类继承抽象类，实现类实现接口，
	    然后通过向上造型方式，完成抽象类、接口的“实例化”。
		抽象类 引用 = new 实体类();//可以
		接口 引用 = new 实现类();//可以
		
	如果抽象类的实体类、接口的实现类，极少使用，
	那作为单独一个类出现就没有多大意义。
	
	实体类、实现类就可以通过匿名内部类方式来实现。

2、封装
   封装不是单纯的知识点，而是一种思想。
方法：对特定功能代码的封装
	类：对具有相似特征，相同行为的对象群体的封装。
		对象特征 → 类的属性
		对象行为 → 类的方法

子父类：对继承、公有代码的封装。
	抽象方法：对没有具体实现的方法进行封装。
	抽象类：对具有抽象方法的类、对代码需要保护的类的封装。
	接口：对规范、标准的封装。
	内部类：对代码保护封装
	匿名内部类：对抽象类的实体类、接口的实现类的封装。

   单独“封装知识点”：
	对于私有属性、私有方法，进行封装。
	
	step1：采用private访问权限修饰。
		对属性、方法，起到只能在本类中才能使用。
	
	step2：属性赋值
	      方式一：
		通过构造方法，创建对象的同时，
		给私有属性赋值。

	      方式二：
		当属性添加private访问权限时，则需要
		对外提供统一的赋值、取值的方法入口。

		赋值：set方法
		取值：get方法

	step3：编写set、get方法
	    a、set方法：
		private String name;

		public void setName(String name){
			this.name = name;
		}
	
	    b、get方法：
		public String getName(){
			return this.name;
		}


	步骤：
	1、对私有属性进行private私有化操作。
	2、对私有属性向外提供统一的入口方法：set、get方法

	为什么要私有化操作：
		提高代码的安全性。

